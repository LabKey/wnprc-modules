<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Zoomable and Draggable SVG Grid</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        svg {
            border: 1px solid black;
            background-color: white;
        }
    </style>
</head>
<body>

<svg id="grid-svg" width="800" height="600"></svg>

<script>
    const svg = d3.select("#grid-svg");
    const width = +svg.attr("width");
    const height = +svg.attr("height");
    let gridSize = 50; // Initial grid size

    // Create a zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.1, 5])
        .on("zoom", handleZoom);

    // Create a drag behavior
    const drag = d3.drag()
        .on("drag", handleDrag);

    // Function to handle zoom
    function handleZoom(event) {
        const transform = event.transform;
        svg.select("g.grid").attr("transform", transform);
        // Dynamically regenerate the grid based on current transform (zoom level)
        updateGrid(transform);
    }

    // Function to handle drag
    function handleDrag(event) {
        const g = d3.select("g.grid");
        const dx = event.dx;
        const dy = event.dy;
        const currentTransform = g.attr("transform") || "translate(0, 0)";
        const newTransform = currentTransform.replace(/translate\(([^,]+),([^)]+)\)/, (match, x, y) => {
            const newX = parseFloat(x) + dx;
            const newY = parseFloat(y) + dy;
            return `translate(${newX}, ${newY})`;
        });
        g.attr("transform", newTransform);
    }

    // Function to dynamically update the grid based on zoom level and current translation
    function updateGrid(transform) {
        const g = d3.select("g.grid");
        g.selectAll("rect").remove(); // Clear existing grid

        // Compute the current visible area based on the transformation
        const visibleWidth = width / transform.k;
        const visibleHeight = height / transform.k;

        // Calculate grid bounds (starting and ending points) based on transform
        const xMin = Math.floor(-transform.x / transform.k / gridSize) * gridSize;
        const yMin = Math.floor(-transform.y / transform.k / gridSize) * gridSize;
        const xMax = Math.ceil((width - transform.x) / transform.k / gridSize) * gridSize;
        const yMax = Math.ceil((height - transform.y) / transform.k / gridSize) * gridSize;

        // Draw the grid within the current visible area
        for (let x = xMin; x < xMax; x += gridSize) {
            for (let y = yMin; y < yMax; y += gridSize) {
                g.append("rect")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("width", gridSize)
                    .attr("height", gridSize)
                    .attr("fill", "none")
                    .attr("stroke", "lightgray");
            }
        }
    }

    // Initial grid setup
    function drawGrid() {
        svg.append("g").attr("class", "grid");
        const initialTransform = d3.zoomIdentity; // Start with identity transform (no zoom, no pan)
        updateGrid(initialTransform); // Draw grid with the initial view
    }

    drawGrid();
    svg.call(zoom); // Enable zoom
    svg.select("g.grid").call(drag); // Enable drag on grid

</script>

</body>
</html>
