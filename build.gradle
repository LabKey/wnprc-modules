import java.util.regex.Pattern

task wrapper(type: Wrapper) {
    gradleVersion = '3.4.1'
}

allprojects {
    repositories {
        maven { url "${project.labkeyArtifactoryUrl}/libs-release" }
        maven { url "${project.labkeyArtifactoryUrl}/libs-snapshot" }
        mavenCentral()
        mavenLocal()
    }
}

ext {
    deployDir = "$rootDir/build/modules"
}

configure(subprojects - project(":docker")) {

    apply plugin: 'java'

    ext {
        explodedModuleDir = "${project.buildDir}/explodedModule"
        configDir         = "${project.explodedModuleDir}/config"
    }

    sourceSets {
        main {
            java { srcDirs = ['src', 'gen-src'] }
        }
        api {
            java { srcDirs = ['api-src'] }
            output.classesDir = "${project.buildDir}/api-classes"
        }
        module {
            resources { srcDirs = ['resources'] }
            output.resourcesDir = project.explodedModuleDir
        }
        spring {
            resources { srcDirs = ["webapp/WEB-INF"] }
            output.resourcesDir = "${project.explodedModuleDir}/config"
        }
    }

    configurations {
        external
        compile.extendsFrom(external)

        apiExternal
        apiCompile.extendsFrom(apiExternal)
    }

    dependencies {
        compile 'org.jetbrains:annotations:15.0'
        apiCompile 'org.jetbrains:annotations:15.0'
    }

    task("processExternalDependencies", group: "Build", type: Copy) {
        from project.configurations.external
        from project.configurations.apiExternal
        into "${project.explodedModuleDir}/lib"
    }

    task("createModuleXml", group: "Build", description: "Create the module.xml file from the module.properties and module.template.xml files") {
        def moduleTemplateFile = file("$rootDir/module.template.xml")
        inputs.file(moduleTemplateFile)

        def modulePropertiesFile = file("module.properties")
        inputs.file(modulePropertiesFile)

        def moduleXmlFile = file("${project.configDir}/module.xml")
        outputs.file(moduleXmlFile)

        doLast {
            final PROPERTY_PATTERN = Pattern.compile("@@([^@]+)@@")

            // read the properties from the module.properties file
            def modProperties = new Properties()
            modulePropertiesFile.withInputStream { modProperties.load(it) }

            // set a few more that are dependent on the build itself
            modProperties.setProperty("BuildType", "Development")
            modProperties.setProperty("BuildPath",  project.explodedModuleDir.toString())
            modProperties.setProperty("SourcePath", project.getProjectDir().getAbsolutePath())
            modProperties.setProperty("ConsolidateScripts", "false")
            modProperties.setProperty("ManageVersion", "false")
            modProperties.setProperty("RequiredServerVersion", "0.0")

            // make sure the config directory exists (and create it if not)
            moduleXmlFile.getParentFile().mkdirs()

            // read the template file and replace all the placeholders
            moduleTemplateFile.withReader { reader ->
                moduleXmlFile.withWriter { writer ->
                    reader.readLines().each { raw ->
                        def matcher = PROPERTY_PATTERN.matcher(raw)
                        def changed = raw
                        while (matcher.find()) {
                            def prp = modProperties.get(matcher.group(1))
                            changed = changed.replace(matcher.group(), prp == null ? "" : prp.toString())
                        }
                        writer.println(changed)
                    }
                }
            }
        }
    }

    task("apiJar", group: "Build", type: Jar, dependsOn: [ apiClasses ]) { Jar jar ->
        jar.classifier "api"
        jar.from project.sourceSets['api'].output.classesDir
        jar.baseName "${project.name}_api"
        jar.destinationDir = file("${project.explodedModuleDir}/lib")
    }

    jar { destinationDir file("${project.explodedModuleDir}/lib") }

    task("createModule", group: "Build", type: Jar, dependsOn: [ jar, apiJar, processExternalDependencies, processModuleResources, createModuleXml ] ) { Jar jar ->
        jar.from file(project.explodedModuleDir)
        jar.baseName project.name
        jar.extension 'module'
        jar.destinationDir project.buildDir
    }

    task("deployModule", group: "Deploy", type: Copy, dependsOn: [ createModule ]) {
        from buildDir
        into rootProject.deployDir
        include '*.module'
    }

    artifacts {
        apiCompile apiJar
    }
}

task ("createModules", group: "Build",  dependsOn: (subprojects - project(":docker")).collect { "${it.path}:createModule" }, description: "Builds and jars the .module file for each subproject")
task ("deployModules", group: "Deploy", dependsOn: (subprojects - project(":docker")).collect { "${it.path}:deployModule" }, description: "Deploys all subprojects")

task ("cleanModules", group: "Deploy", type: Delete, description: "Cleans the modules from the deploy directory") {
    delete deployDir
}

task ("cleanAll", group: "Build", type: Delete, dependsOn: (subprojects - project(":docker")).collect { "${it.path}:clean" }, description: "Cleans all the build artifacts")
cleanAll.dependsOn(":cleanModules")
