/***********************************************************************************************************************
 * wnprc-modules "main" build file
 *
 * This file is the "main" build definition for the wnprc-modules folders that lie under it, with the caveat that this
 * file itself is expected to be a subproject of the main _LabKey_ build. As such, the folder structure is assumed to
 * be as follows:
 *
 *   [labkey root]
 *     -> externalModules
 *       -> wnprc-modules (this folder)
 *         -> docker
 *         -> lib
 *         -> [module]
 *         -> [module]
 *         ...
 *
 * To include all the subprojects (including docker, which does get some special treatment later), add the following to
 * the top-level (LabKey root) settings.gradle file or to a "module set" in [labkey root]/gradle/settings:
 *
 *   include 'externalModules:wnprc-modules'
 *   file('externalModules/wnprc-modules').listFiles().findAll { d ->
 *     d.isDirectory() && (new File(d.getAbsolutePath(), 'build.gradle')).exists()
 *   }.each { d ->
 *     include "externalModules:wnprc-modules:${d.getName()}"
 *   }
 *
 * In case it is not immediately obvious, that code will add every subfolder containing a build.gradle file as a
 * subproject to the gradle build under the ":externalModules:wnprc-modules" project.
 *
 * Each module subproject (i.e., not docker) will automatically get the 'java' plugin (and corresponding sourceSets)
 * and a few module-specific tasks:
 *
 *   - createModuleXml
 *   - createModule
 *   - deployModule
 *   - undeployModule
 *
 * The "main" wnprc-modules build also has some tasks to manage all the modules:
 *
 *   - createModules
 *   - deployModules
 *   - undeployModules
 *
 **********************************************************************************************************************/
import java.util.regex.Pattern

// using this to manage our node_modules and package.json in the base directory rather than module by module
apply plugin: 'com.moowork.node'

// using this to ignore the node_modules and other "base" folders in IntelliJ IDEA
apply plugin: 'idea'
idea.module {
    excludeDirs += file('node_modules')
}

// set up the LabKey artifactory and the local maven repository (~/.m2) as build sources. this would
// be of more use if we were building modules "externally" rather than inside the exising LabKey structure
allprojects {
    repositories {
        maven { url "${project.labkeyArtifactoryUrl}/libs-release" }
        maven { url "${project.labkeyArtifactoryUrl}/libs-snapshot" }
        mavenCentral()
        mavenLocal()
    }
}

ext {
    // directory from which the development version of LabKey will deploy modules
    deployDir = "$rootDir/build/deploy/modules"

    // directory into which .module files are staged (presumably for production builds)
    stagingDir = "$rootDir/build/staging/modules"
}

def modules = subprojects - project("docker")
configure(modules) {

    apply plugin: 'java'
    apply plugin: 'idea'

    idea.module {
        excludeDirs += file('build')
    }

    ext {
        explodedModuleDir = "${project.buildDir}/explodedModule"
        configDir         = "${project.explodedModuleDir}/config"
    }

    sourceSets {
        main {
            java { srcDirs = ['src'] }
        }
        api {
            java { srcDirs = ['api-src'] }
            output.classesDir = "${project.buildDir}/api-classes"
        }
        module {
            resources { srcDirs = ['resources'] }
            output.resourcesDir = project.explodedModuleDir
        }
        spring {
            resources { srcDirs = ["webapp/WEB-INF"] }
            output.resourcesDir = "${project.explodedModuleDir}/config"
        }
    }

    configurations {
        external
        compile.extendsFrom(external)

        apiExternal
        apiCompile.extendsFrom(apiExternal)
    }

    compileJava {
        options.compilerArgs << "-Werror"
    }

    compileApiJava {
        options.compilerArgs << "-Werror"
    }

    dependencies {
        apiCompile 'org.jetbrains:annotations:15.0'
        apiCompile project(":server:api")
        compile 'org.jetbrains:annotations:15.0'
        compile project(":server:api")
        compile project(":externalModules:labModules:LDK")
    }

    task("processExternalDependencies", group: "Build", type: Copy) {
        from project.configurations.external
        from project.configurations.apiExternal
        into "${project.explodedModuleDir}/lib"
    }

    task("createModuleXml", group: "Build", description: "Create the module.xml file from the module.properties and module.template.xml files") {
        def moduleTemplateFile = file("${project.projectDir}/../module.template.xml")
        inputs.file(moduleTemplateFile)

        def modulePropertiesFile = file("module.properties")
        inputs.file(modulePropertiesFile)

        def moduleXmlFile = file("${project.configDir}/module.xml")
        outputs.file(moduleXmlFile)

        doLast {
            final PROPERTY_PATTERN = Pattern.compile("@@([^@]+)@@")

            // read the properties from the module.properties file
            def modProperties = new Properties()
            modulePropertiesFile.withInputStream { modProperties.load(it) }

            // set a few more that are dependent on the build itself
            modProperties.setProperty("BuildType", project.hasProperty('deployMode') ? project.property('deployMode') : 'Development')
            modProperties.setProperty("BuildPath",  project.explodedModuleDir.toString())
            modProperties.setProperty("SourcePath", project.getProjectDir().getAbsolutePath())
            modProperties.setProperty("ConsolidateScripts", "false")
            modProperties.setProperty("ManageVersion", "false")
            modProperties.setProperty("RequiredServerVersion", "0.0")

            // make sure the config directory exists (and create it if not)
            moduleXmlFile.getParentFile().mkdirs()

            // read the template file and replace all the placeholders
            moduleTemplateFile.withReader { reader ->
                moduleXmlFile.withWriter { writer ->
                    reader.readLines().each { raw ->
                        def matcher = PROPERTY_PATTERN.matcher(raw)
                        def changed = raw
                        while (matcher.find()) {
                            def prp = modProperties.get(matcher.group(1))
                            changed = changed.replace(matcher.group(), prp == null ? "" : prp.toString())
                        }
                        writer.println(changed)
                    }
                }
            }
        }
    }

    task("apiJar", group: "Build", type: Jar, dependsOn: [ apiClasses ]) { Jar jar ->
        jar.classifier "api"
        jar.from project.sourceSets['api'].output.classesDir
        jar.baseName "${project.name}_api"
        jar.destinationDir = file("${project.explodedModuleDir}/lib")
    }

    jar { destinationDir file("${project.explodedModuleDir}/lib") }

    // creates the .module file from the exploded module directory in the build folder and copies that
    // jar file to the staging directory for later consumption
    task("createModule", group: "Build", type: Jar, dependsOn: [ jar, apiJar, processExternalDependencies, processModuleResources, createModuleXml ] ) { Jar jar ->
        jar.from file(project.explodedModuleDir)
        jar.baseName project.name
        jar.extension 'module'
        jar.destinationDir file(stagingDir)
    }

    // copies the project-specific .module file from the staging directory into the deploy directory
    task("deployModule", group: "Deploy", type: Copy, dependsOn: [ createModule ]) {
        from stagingDir
        into deployDir
        include "${project.name}-${project.version}.module"
    }

    // removes the .module file and the exploded directory from the deploy directory
    task("undeployModule", group: "Deploy", type: Delete) {
        delete "$deployDir/${project.name}-${project.version}", "$deployDir/${project.name}-${project.version}.module"
    }

    // removes the .module file from the staging directory (and undeploys it, too)
    task("cleanModule", group: "Build", type: Delete, dependsOn: [ undeployModule ]) {
        delete "$stagingDir/${project.name}-${project.version}.module"
    }

    artifacts {
        apiCompile apiJar
    }
}

task ("createModules",   group: "Build",  dependsOn: modules.collect { "${it.path}:createModule" },   description: "Builds and jars the .module file for each subproject")
task ("deployModules",   group: "Deploy", dependsOn: modules.collect { "${it.path}:deployModule" },   description: "Deploys all child modules")
task ("undeployModules", group: "Deploy", dependsOn: modules.collect { "${it.path}:undeployModule" }, description: "Undeploys all child modules")
task ("cleanModules",    group: "Build",  dependsOn: modules.collect { "${it.path}:cleanModule" },    description: "Cleans/unstages all child modules")