/***********************************************************************************************************************
 * wnprc-modules "main" build file
 *
 * This file is the "main" build definition for the wnprc-modules folders that lie under it, with the caveat that this
 * file itself is expected to be a subproject of the main _LabKey_ build. As such, the folder structure is assumed to
 * be as follows:
 *
 *   [labkey root]
 *     -> externalModules
 *       -> wnprc-modules (this folder)
 *         -> docker
 *         -> lib
 *         -> [module]
 *         -> [module]
 *         ...
 *
 * To include all the subprojects (including docker, which does get some special treatment later), add the following to
 * the top-level (LabKey root) settings.gradle file or to a "module set" in [labkey root]/gradle/settings:
 *
 *   include 'externalModules:wnprc-modules'
 *   file('externalModules/wnprc-modules').listFiles().findAll { d ->
 *     d.isDirectory() && (new File(d.getAbsolutePath(), 'build.gradle')).exists()
 *   }.each { d ->
 *     include "externalModules:wnprc-modules:${d.getName()}"
 *   }
 *
 * In case it is not immediately obvious, that code will add every subfolder containing a build.gradle file as a
 * subproject to the gradle build under the ":externalModules:wnprc-modules" project.
 *
 * Each module subproject (i.e., not docker) will automatically get the 'java' plugin (and corresponding sourceSets)
 * and a few module-specific tasks:
 *
 *   - createModuleXml
 *   - createModule
 *   - deployModule
 *   - undeployModule
 *
 * The "main" wnprc-modules build also has some tasks to manage all the modules:
 *
 *   - createModules
 *   - deployModules
 *   - undeployModules
 *
 **********************************************************************************************************************/
import java.util.regex.Pattern

// using this to manage our node_modules and package.json in the base directory rather than module by module
apply plugin: 'com.moowork.node'

// using this to ignore the node_modules and other "base" folders in IntelliJ IDEA
apply plugin: 'idea'
idea.module {
    excludeDirs += file('node_modules')
}

// set up the LabKey artifactory and the local maven repository (~/.m2) as build sources. this would
// be of more use if we were building modules "externally" rather than inside the exising LabKey structure
allprojects {
    repositories {
        maven { url "${project.labkeyArtifactoryUrl}/libs-release" }
        maven { url "${project.labkeyArtifactoryUrl}/libs-snapshot" }
        mavenCentral()
        mavenLocal()
    }
}

ext {
    // directory from which the development version of LabKey will deploy modules
    deployDir = "$rootDir/build/deploy/modules"

    // directory into which .module files are staged (presumably for production builds)
    stagingDir = "$rootDir/build/staging/modules"
}

def modules = subprojects - project("docker")
configure(modules) {

    apply plugin: 'java'
    apply plugin: 'idea'

    idea.module {
        excludeDirs += file('build')
    }

    ext {
        explodedModuleDir = "${project.buildDir}/explodedModule"
        configDir         = "${project.explodedModuleDir}/config"
    }

    sourceSets {
        main {
            java { srcDirs = ['src'] }
        }
        api {
            java { srcDirs = ['api-src'] }
            output.classesDir = "${project.buildDir}/api-classes"
        }
        module {
            resources { srcDirs = ['resources'] }
            output.resourcesDir = project.explodedModuleDir
        }
        spring {
            resources { srcDirs = ["webapp/WEB-INF"] }
            output.resourcesDir = "${project.explodedModuleDir}/config"
        }
        jsp {
            java { srcDirs = ["$buildDir/jspTempDir/classes"] }
            output.classesDir = "$buildDir/jspTempDir/classes"
        }
    }

    configurations {
        external
        compile.extendsFrom(external)

        apiExternal
        apiCompile.extendsFrom(apiExternal)

        jspCompile
        jsp
    }

    project.configurations.jspCompile {
        resolutionStrategy {
            force "javax.servlet:servlet-api:3.0"
        }
    }

    compileJava {
        options.compilerArgs << "-Werror"
    }

    compileApiJava {
        options.compilerArgs << "-Werror"
    }

    dependencies {
        apiCompile 'org.jetbrains:annotations:15.0'
        apiCompile project(":server:api")
        compile 'org.jetbrains:annotations:15.0'
        compile project(":server:api")
        compile project(":externalModules:labModules:LDK")
        jspCompile 'org.apache.tomcat:jasper'
        jspCompile 'org.apache.tomcat:jsp-api'
        jspCompile 'org.apache.tomcat:tomcat-juli'
        jspCompile fileTree(dir: "${project.tomcatDir}/lib", includes: ['*.jar'])
        jspCompile project.files(project.tasks.jar)
        if (project.hasProperty('apiJar')) {
            jspCompile project.files(project.tasks.apiJar)
        }
        jsp 'org.apache.tomcat:jasper'
        jsp 'org.apache.tomcat:bootstrap'
        jsp 'org.apache.tomcat:tomcat-juli'
    }

    task("processExternalDependencies", group: "Build", type: Copy) {
        from project.configurations.external
        from project.configurations.apiExternal
        into "${project.explodedModuleDir}/lib"
    }

    task("createModuleXml", group: "Build", description: "Create the module.xml file from the module.properties and module.template.xml files") {
        def moduleTemplateFile = file("${project.projectDir}/../module.template.xml")
        inputs.file(moduleTemplateFile)

        def modulePropertiesFile = file("module.properties")
        inputs.file(modulePropertiesFile)

        def moduleXmlFile = file("${project.configDir}/module.xml")
        outputs.file(moduleXmlFile)

        doLast {
            final PROPERTY_PATTERN = Pattern.compile("@@([^@]+)@@")

            // read the properties from the module.properties file
            def modProperties = new Properties()
            modulePropertiesFile.withInputStream { modProperties.load(it) }

            // set a few more that are dependent on the build itself
            modProperties.setProperty("BuildType", project.hasProperty('deployMode') ? project.property('deployMode') : 'Development')
            modProperties.setProperty("BuildPath",  project.explodedModuleDir.toString())
            modProperties.setProperty("SourcePath", project.getProjectDir().getAbsolutePath())
            modProperties.setProperty("ConsolidateScripts", "false")
            modProperties.setProperty("ManageVersion", "false")
            modProperties.setProperty("RequiredServerVersion", "0.0")

            // make sure the config directory exists (and create it if not)
            moduleXmlFile.getParentFile().mkdirs()

            // read the template file and replace all the placeholders
            moduleTemplateFile.withReader { reader ->
                moduleXmlFile.withWriter { writer ->
                    reader.readLines().each { raw ->
                        def matcher = PROPERTY_PATTERN.matcher(raw)
                        def changed = raw
                        while (matcher.find()) {
                            def prp = modProperties.get(matcher.group(1))
                            changed = changed.replace(matcher.group(), prp == null ? "" : prp.toString())
                        }
                        writer.println(changed)
                    }
                }
            }
        }
    }

    task("apiJar", group: "Build", type: Jar, dependsOn: [ apiClasses ]) { Jar jar ->
        jar.classifier "api"
        jar.from project.sourceSets['api'].output.classesDir
        jar.baseName "${project.name}_api"
        jar.destinationDir = file("${project.explodedModuleDir}/lib")
    }

    jar { destinationDir file("${project.explodedModuleDir}/lib") }

    task('copyJsp', group: "Build", type: Copy, description: "Copy jsp files to jsp compile directory",
            { CopySpec copy ->
                copy.from 'src'
                copy.into "${project.buildDir}/jspTempDir/webapp"
                copy.include '**/*.jsp'
            }).doFirst {
        project.delete "${project.buildDir}/jspTempDir/webapp/org"
    }

    task('copyResourceJsp', group: "Build", type: Copy, description: "Copy resource jsp files to jsp compile directory") { CopySpec copy ->
        copy.from 'resources'
        copy.into "${project.buildDir}/jspTempDir/webapp/org/labkey/${project.name}"
        copy.include '**/*.jsp'
    }

    task('copyTagLibs', group: "Build", type: Copy, description: "Copy the tag library (.tld) files to jsp compile directory",
            { CopySpec copy ->
                copy.from "${project.rootProject.buildDir}/webapp"
                copy.into "${project.buildDir}/jspTempDir/webapp"
                copy.include 'WEB-INF/web.xml'
                copy.include 'WEB-INF/*.tld'
                copy.include 'WEB-INF/tags/**'
            })

    task('jsp2Java', group: "Build", description: "compile jsp files into Java classes") {
        inputs.file copyJsp
        inputs.file copyResourceJsp
        inputs.file copyTagLibs
        outputs.dir "${project.buildDir}/jspTempDir/classes"

        doFirst {
            project.delete "${project.buildDir}/jspTempDir/classes"
        }

        if (project.hasProperty('apiJar'))
            dependsOn 'apiJar'
        dependsOn 'jar'

        doLast {
            File uriRoot = new File("${project.buildDir}/jspTempDir/webapp")
            if (!uriRoot.exists())
                uriRoot.mkdirs();
            ant.taskdef(
                    name: 'jasper',
                    classname: 'org.apache.jasper.JspC',
                    classpath: project.configurations.jspCompile.asPath
            )
            ant.jasper(
                    uriroot: "${project.buildDir}/jspTempDir/webapp",
                    outputDir: "${project.buildDir}/jspTempDir/classes",
                    package: "org.labkey.jsp.compiled",
                    compilerTargetVM: project.targetCompatibility,
                    compilerSourceVM: project.sourceCompatibility,
                    trimSpaces: false,
                    compile: false,
                    listErrors: true
            )
        }
    }

    task('jspJar', group: "Build", type: Jar, description: "produce jar file of jsps", dependsOn: [ 'jsp2Java' ]) { Jar jar ->
        jar.classifier = 'jsp'
        jar.from "${project.buildDir}/jspTempDir/classes"
        jar.baseName = "${project.name}_jsp"
        jar.destinationDir = project.file("$buildDir/explodedModule/lib")
    }

    if (file("$projectDir/tsconfig.json").exists()) {

        task("java2ts", type: JavaExec) {

            doFirst {
                mkdir "$projectDir/build/generated-ts"
            }

            main = 'com.github.jonathonrichardson.java2ts.Compiler'
            classpath = sourceSets.main.runtimeClasspath
            args = [ "$projectDir/build/generated-ts/GeneratedFromJava.ts" ]

            inputs.dir("$projectDir/src/java")
            outputs.dir("$projectDir/build/generated-ts")
        }

        task("compileTypescript", type: Exec, dependsOn: ["java2ts", "${project.parent.path}:npmInstall"]) {
            workingDir "$projectDir"
            commandLine "../node_modules/.bin/tsc"

            inputs.file("$projectDir/tsconfig.json")
            inputs.dir("$projectDir/src/ts")
            inputs.dir("$projectDir/build/generated-ts")
            outputs.dir("$projectDir/build/compiled-ts")
        }

        project.tasks.findByName("processModuleResources").dependsOn("compileTypescript")
    }

    if (file("$projectDir/webpack.config.js").exists()){
        task("webpack", type: Exec) {
            if (project.tasks.findByName("compileTypescript")) {
                dependsOn compileTypescript
            }
            workingDir "$projectDir"
            commandLine "../node_modules/.bin/webpack", "--env.BUILD_DIR='$buildDir'"
        }
        project.tasks.findByName("processModuleResources").dependsOn("webpack")
    }

    // creates the .module file from the exploded module directory in the build folder and copies that
    // jar file to the staging directory for later consumption
    task("createModule", group: "Build", type: Jar, dependsOn: [ jar, apiJar, processExternalDependencies, processModuleResources, createModuleXml ] ) { Jar jar ->
        jar.from file(project.explodedModuleDir)
        jar.baseName project.name
        jar.extension 'module'
        jar.destinationDir file(stagingDir)
    }

    // copies the project-specific .module file from the staging directory into the deploy directory
    task("deployModule", group: "Deploy", type: Copy, dependsOn: [ createModule ]) {
        from stagingDir
        into deployDir
        include "${project.name}-${project.version}.module"
    }

    // removes the .module file and the exploded directory from the deploy directory
    task("undeployModule", group: "Deploy", type: Delete) {
        delete "$deployDir/${project.name}-${project.version}", "$deployDir/${project.name}-${project.version}.module"
    }

    // removes the .module file from the staging directory (and undeploys it, too)
    task("cleanModule", group: "Build", type: Delete, dependsOn: [ undeployModule ]) {
        delete "$stagingDir/${project.name}-${project.version}.module"
    }

    artifacts {
        apiCompile apiJar
        jspCompile jspJar
    }
}

task ("createModules",   group: "Build",  dependsOn: modules.collect { "${it.path}:createModule" },   description: "Builds and jars the .module file for each subproject")
task ("deployModules",   group: "Deploy", dependsOn: modules.collect { "${it.path}:deployModule" },   description: "Deploys all child modules")
task ("undeployModules", group: "Deploy", dependsOn: modules.collect { "${it.path}:undeployModule" }, description: "Undeploys all child modules")
task ("cleanModules",    group: "Build",  dependsOn: modules.collect { "${it.path}:cleanModule" },    description: "Cleans/unstages all child modules")